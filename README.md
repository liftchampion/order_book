# "Биржевой стакан"

**Задача**: реализовать систему хранения данных, в которой цене будет ставиться количество товара, которое готовы продать/купить по данной цене. Строго говоря это не является "биржевым стаканом", а лишь его половиной. "Стакан" состоит из двух таких систем хранения, одной для продавцов, другой для покупателей.
**Решение**: контейнер был реализован в двух версиях:  
+ В одной из них в качестве основы был взят std::vector, детали реализации указаны в комментариях в файле [offers_list_class.h](https://github.com/liftchampion/order_book/blob/master/offers_list_class.h). Код данной реализации содержится во всех файлах, кроме нижеуказанных.  
+ В другой в качестве основы использовался std::map. К данной реализации относятся файлы [map_version.h](https://github.com/liftchampion/order_book/blob/master/map_version.h) и [map_version.cpp](https://github.com/liftchampion/order_book/blob/master/map_version.cpp)  


**Итоги**: 
+ Вставка/изменение значения: реализация с вектором показывает себя в 2-4 раза лучше реализации со словарём, если  обращение к одинаковым элементам контейнера происходят множество раз. Если в векторной реализации при вставке не происходит "перестраивания" контейнера, то она осуществялется за O(1), в отличие от O(logN) у словаря. Избежать ненужных "перестраиваний" позволяет заблаговременное указание offset'а и step'а для контейнера. Это позволяет понизить пороговое количество обращений, при которых вектор обгоняет словарь.  
+ Печать: вывод данных контейнеров на экран занимает одинаковое количество времени.  
+ Удаление: так как удаление происходит путём присванивания текущей цене количества 0, поведение ничем не отличается от вставки/изменения значения.  
+ "Перестройка": "перестройкой" в контексте данных контейнеров будем называть удаление нулевых элементов для оптимизации расхода памяти. В случае реализации через вектор, так же выбирается новые offset и step, позволяющие оптимальнее хранить данные. В зависимости от общего количества элементов и количества пустых элементов, "перестройка" вектора происходит в 2-10 раз быстрее.  
+ Промах: в силу специфики реализации контейнера через вектор, при вставке элемента с ценой, точность или пороговое значение которой (step и offset) не позволяют без "перестройки" положить его в контейнер, вставка таких элементов может занимать достаточно много времени и сильно увеличивать расход памяти. В большинстве случаев "перестройка" не занимает много времени, особенно если проблема в offset'е. Но "перестройка", при которой меняется step, может оказаться гораздо дольше, так например на массиве из 10млн элементов, вставка одного промаха заняла 30 секунд. Что не удивительно, ведь при этом размер контейнера увеличился почти в 10, при чём происходила инициализация всех 100млн элементов вектора.


**Выводы**: Исходя из результатов и специфики задачи можно сделать вывод, что реализация через вектор хорошо подходит для хранения такого рода данных. Так как цены, в большинстве случаев не сильно друг от друга отличаются, и чем выше точность, тем ниже их разброс, то контейнер не будет тратить слишком много лишней памяти, и не будет замедляться из-за "промахов".  
Однако, если предполагается, что разброс цен будет большим, а "стакан" пустым и разреженным, то следует поспользоваться реализацией через словарь.  

### Пример вывода на экран до и после удалений
![output](https://raw.githubusercontent.com/liftchampion/order_book/master/screenshot.png)
